A (dynamic) range, as defined in C\+\+20, is, logically, a sequence of elements that can be iterated using run-time constructs like loops. Since C\+\+ is a statically-typed language, the iteration by loops implies that all elements of a dynamic range must have the same type. The main purpose of static ranges is to overcome this limitation.

## Static range
A static range is, logically, a sequence of elements such that:

- The number of elements can be determined at compile time.
- The type of an element can be determined at compile time.
- The sequence may be heterogeneous, i.e. different elements may have different types.

For instance, the types ```std::tuple```, ```std::pair```, and ```std::array``` may, logically, serve as static ranges (although the array does not exhibit heterogeneity of element types).

```C++
struct example_s {
    int u;
    double v;
    std::string w;
};

template<>
struct static_ranges::range_traits<example_s> 
: std::integral_constant<std::size_t, 3> 
{
    template<std::size_t I, typename T2>
    static auto&& get(T2&& r)
    {
        if constexpr (I == 0) { return std::forward<T2>(r).u; }
        if constexpr (I == 1) { return std::forward<T2>(r).v; }
        if constexpr (I == 2) { return std::forward<T2>(r).w; }
    }
};
```
The ```static_ranges::range_traits<example_s>``` struct is an explicit specialization of the template ```static_ranges::range_traits``` which serves as the adaptor that enables the use of the type example_s as a static range.

The inherited ```std::integral_constant``` specifies the number of elements of the static range and the static member function get provides access to the elements in the same way as ```std::get```.

## Accessing elements of static ranges
```C++
template< typename R>
void example_f(R && r)
{
    static_assert(static_ranges::size_v<R> == 3, "size must be 3");

    static_ranges::element<0>(r) += 42;
    static_ranges::element<1>(r) += 3.14;
    static_ranges::element<2>(r) += "Bar";

    std::cout << "0: " << static_ranges::element<0>(r) << std::endl;
    std::cout << "1: " << static_ranges::element<1>(r) << std::endl;
    std::cout << "2: " << static_ranges::element<2>(r) << std::endl;
}
```
The example_f function shall work with the example_s struct as well as with std::tuple<int,double,std::string>.

## Iteration through static ranges

Due to the heterogeneity of element types, static ranges cannot be iterated using run-time constructs like loops; instead, a sequence of code snippets tailored to each element type must be used. Such a sequence may be generated by the template machinery of C++, using recursion or fold-expressions.

For example, the example_f function above may be reimplemented as:

```C++
template< typename R>
void example_f_v2(R && r)
{
    static_assert(static_ranges::size_v<R> == 3, "size must be 3");

    auto values = std::make_tuple(42, 3.14, "Bar");
    auto adder = [](auto && a, auto && b){
        return a + b;
    };
    static_ranges::transform(r, values, r, adder);

    auto numbers = static_ranges::iota<int,static_ranges::size_v<R>>();
    auto packager = [](int i, auto && a){
        return std::make_pair(i, a);
    };
    template<std::size_t I>
    using my_pair = std::pair<int,std::remove_cvref_t<decltype(static_ranges::element<I>(r))>>;
    std::tuple<my_pair<0>, my_pair<1>, my_pair<2>> tmp;
    static_ranges::transform(numbers, r, tmp, packager);

    auto printer = [](auto && p){
        std::cout << p.first << ": " << p.second << std::endl;
    };
    static_ranges::for_each(tmp, printer);
}
```

## Static views
Static views provide a lazy-evaluation alternative to the use of algorithms on static ranges. The syntax and semantics is similar to ```std::views```.
In general, static views do not store their elements; instead, they store references to other static ranges and/or compute the elements on the fly. As a result, copying a static view shall be fast.


## Reference documentation
### Namespaces
- static_ranges
    - Dynamic analog: ```std::ranges```
    - A namespace containing declarations related to static ranges
- static_ranges::views
    - Dynamic analog: ```std::ranges::views```
    - A namespace containing declarations related to static views
- ```static_views = static_ranges::views```
    - Dynamic analog: ```std::views```
    - A namespace alias
    
### Common declarations

- ```static_ranges::range_traits```
    - A declaration of the following template:
        ```C++
        template< typename T> struct range_traits
        ```
- ```static_ranges::view_base```
    - An empty struct
    - Inherited to denote static ranges that satisfy the ```static_ranges::view``` concept
    
### Library parts
#### all_view
- ```static_ranges::views::all```
    - Dynamic analog: ```std::ranges::views::all```
    - The expression
        ```C++
            static_ranges::views::all(e)
        ```
        returns:
        - An rvalue identical to e (i.e. copied or moved from e), if e is a static view.
        - Otherwise, a view object which behaves as a reference to e.

#### concepts
- ```static_ranges::range```
    - Dynamic analog: ```std::ranges::range```
    - The concept ```static_ranges::range<T>``` is satisfied if T is a type (or a reference to a type) that represents a static range, i.e.
        - The template specialization ```static_ranges::range_traits<std::remove_cvref_t<T>>``` is defined
        - The expression
            ```C++
            static_ranges::range_traits<std::remove_cvref_t<T>>::value
            ```
            is a constant expression of type ```std::size_t```
    - The expression
        ```C++
        static_ranges::range_traits<std::remove_cvref_t<T>>::template get<I>(e)
        ```
        is defined for:
        - any expression r of type T
        - any integer I such that 0 <= I < ```static_ranges::range_traits<std::remove_cvref_t<T>>::value```
        
- ```static_ranges::view```
    - Dynamic analog: ```std::ranges::view```
    - The concept ```static_ranges::view<T>``` is satisfied if T is a type (or a reference to a type) that represents a static view, i.e.
        - ```static_ranges::range<T>``` is satisfied, and
        - the class ```std::remove_cvref_t<T>``` is derived from ```static_ranges::view_base```
        
#### convenience
- ```static_ranges::size_v```
    - Dynamic analog: ```std::ranges::size```
    - The expression ```static_ranges::size_v<T>``` is a constant expression of type ```std::size_t``` representing the size of the static range T, i.e. it is equal to
        ```C++
        static_ranges::range_traits<std::remove_cvref_t<T>>::value
        ```
    
- ```static_ranges::element```
    - Dynamic analog: ```*std::next(std::ranges::begin(e),I)```
    - The expression ```static_ranges::element<I>(e)``` returns (a reference to) the I-th element of the static range r, i.e. it is equal to
    ```static_ranges::range_traits<std::remove_cvref_t<decltype(e)>>::template get<I>(e)```

#### copy
- ```static_ranges::copy```
    - Dynamic analog: ```std::ranges::copy```
    - The statement 
        ```C++
        static_ranges::copy(r1,r2);
        ```
        copies all elements of the static range ```r1``` into the static range ```r2```
        - The static ranges ```r1``` and ```r2``` must have the same number of elements
        - The ```I```-th element of ```r1``` must be copy-assignable to the ```I```-th element of ```r2```
        
#### for_each
- ```static_ranges::for_each```
    - Dynamic analog: ```std::ranges::for_each```
    - The statement
        ```C++
        static_ranges::for_each(r,f);
        ```
        applies ```f(e)``` to every element ```e``` of the static range ```r```
        - Note: ```f(e)``` may modify the element ```e``` inside the range ```r```
        
#### iota_view
- ```static_ranges::views::iota```
    - Dynamic analog: ```std::ranges::views::iota```
    - The expression
        ```C++
        static_ranges::views::iota<T,N>()
        ```
        returns a static view containing the elements ```{0,1,...,N-1}``` of type ```T```.
        - ```T``` shall be an integral type
        
#### static_iota_view
- ```static_ranges::views::static_iota```
    - Dynamic analog: ```std::ranges::views::iota```
    - The expression
        ```C++
        static_ranges::views::static_iota<T,N>()
        ```
        returns a static view representing the values ```{0,1,...,N-1}``` in the following way:
        - the ```I```-th element eI is an empty object such that the expression ```decltype(eI)::value``` is a constant expression with value ```I``` of type ```T```
        - Note: The expression eI.value will work too
        - ```T``` is an integral type

#### std
- Ensures that the types ```std::tuple```, ```std::pair```, and ```std::array``` work as static ranges, through the definition of the following specializations:
- ```static_ranges::range_traits<std::tuple<TL...>>```
- ```static_ranges::range_traits<std::pair<T1,T2>>```
- ```static_ranges::range_traits<std::array<T,N>>```

#### to
- ```static_ranges::to_tuple```
    - The expression
        ```C++
        static_ranges::to_tuple(r)
        ```
         returns a ```std::tuple``` containing copies of the elements of the static range ```r```
         
- ```static_ranges::to_pair```
    - The expression
        ```C++
        static_ranges::to_pair(r)
        ```
        returns a ```std::pair``` containing copies of the elements of the static range r
        - r must have exactly 2 elements
        
- ```static_ranges::to_array```
    - The expression
        ```C++
        static_ranges::to_array<T>(r)
        ```
         returns a ```std::array<T,N>``` containing (possibly converted) copies of the elements of the static range ```r```
            - T must be copy-constructible from all the element types in ```r```
            
#### transform_view
- ```static_ranges::view::operator|```
    - The pipeline operator on views: The expression ```r|c``` shall be equivalent to ```c(r)``` for a static range ```r``` and a range adaptor closure object (obtained, for instance, by calling ```static_ranges::view::transform```)
    
- ```static_ranges::view::transform```
    - Dynamic analog: ```std::ranges::views::transform```
    - The expression
        ```C++
        static_ranges::view::transform(r,f)
        ```
        returns a static view of the same size as the static range ```r```
        - For each element ```eI``` of ```r```, the resulting static view contains the value ```f(eI)```
    - The expression
        ```C++
        static_ranges::view::transform(f)
        ```
        returns a range adaptor closure object such that ```static_ranges::view::transform(r,f)``` is equivalent to both these expressions:
            - ```static_ranges::view::transform(f)(r)```
            - ```r | static_ranges::view::transform(f)```
            
#### transform
- ```static_ranges::transform```
        - Dynamic analog: ```std::ranges::transform```
        - The expression
        ```
        static_ranges::transform(r1,r2,f);
        ```
        copies the value ```f(e1I)``` for every element ```e1I``` of the static range ```r1``` into the corresponding element ```e2I``` of the static range ```r2```
                - The static ranges ```r1``` and ```r2``` must have the same number of elements
                - ```f(e1I)``` must be copy-assignable to the ```I```-th element of ```r2```
        - The statement
        ```
            static_ranges::transform(r1,r2,r3,f);
        ```
        copies the value ```f(e1I,e2I)``` for every element ```e1I``` of the static range ```r1``` and the corresponding element ```e2I``` of the static range ```r2``` into the corresponding element ```e3I``` of the static range ```r3```
            - The static ranges ```r1```, ```r2```, and ```r3``` must have the same number of elements
            - ```f(e1I,e2I)``` must be copy-assignable to the ```I```-th element of ```r3```
